abline(0,1)
plot(mod.compare.df[,1], mod.compare.df[,3], main = "Reduced Model - 650 wavelengths", xlab = "Observed TSV", ylab = "Predicted TSV")
summary(lm(mod.compare.df2[,1]~mod.compare.df2[,3]))
abline(0,1)
plot(mod.compare.df2[,1], mod.compare.df2[,3], main = "Reduced Model - 4 bands", xlab = "Observed TSV", ylab = "Predicted TSV")
summary(lm(mod.compare.df2[,1]~mod.compare.df2[,3]))
abline(0,1)
coefplot(tsv1, ncomp = 1:4)
plot(mod.compare.df[,1], mod.compare.df[,2], main = "Full Model")
par(mfrow=c(1,1))
plot(mod.compare.df[,1], mod.compare.df[,2], main = "Full Model")
#summary(lm(mod.compare.df[,1]~mod.compare.df[,2]))
abline(0,1)
plot(mod.compare.df[,1], mod.compare.df[,3], main = "Reduced Model")
#summary(lm(mod.compare.df[,1]~mod.compare.df[,3]))
abline(0,1)
mod.compare.df = data.frame(mmtsv$TSV, predict(tsv1, ncomp = 4), predict(tsv2.red,ncomp = 4))
par(mfrow=c(1,1))
plot(mod.compare.df[,1], mod.compare.df[,2], main = "Full Model")
#summary(lm(mod.compare.df[,1]~mod.compare.df[,2]))
abline(0,1)
plot(mod.compare.df[,1], mod.compare.df[,3], main = "Reduced Model")
abline(0,1)
#summary(lm(mod.compare.df[,1]~mod.compare.df[,3]))
panes(1,2)
plot(mod.compare.df[,1], mod.compare.df[,2], main = "Full Model")
#summary(lm(mod.compare.df[,1]~mod.compare.df[,2]))
abline(0,1)
plot(mod.compare.df[,1], mod.compare.df[,3], main = "Reduced Model")
#summary(lm(mod.compare.df[,1]~mod.compare.df[,3]))
abline(0,1)
mod.compare.df2 = data.frame(mmtsv$TSV, predict(tsv1, ncomp = 4), predict(tsv3.bands.pls,ncomp = 4))
panes(1,1)
plot(mod.compare.df2[,1], mod.compare.df2[,2], main = "Full Model - All Wavelengths", xlab = "Observed TSV", ylab = "Predicted TSV")
summary(lm(mod.compare.df2[,1]~mod.compare.df2[,2]))
abline(0,1)
plot(mod.compare.df[,1], mod.compare.df[,3], main = "Reduced Model - 650 wavelengths", xlab = "Observed TSV", ylab = "Predicted TSV")
summary(lm(mod.compare.df2[,1]~mod.compare.df2[,3]))
abline(0,1)
plot(mod.compare.df2[,1], mod.compare.df2[,3], main = "Reduced Model - 4 bands", xlab = "Observed TSV", ylab = "Predicted TSV")
summary(lm(mod.compare.df2[,1]~mod.compare.df2[,3]))
abline(0,1)
par(mfrow=c(1,1))
loadingplot(tsv1, comps = 1:2, legendpos = "topright", labels = c(401:2500), xlab = "Wavelength (nm)")
abline(h=0)
loadingplot(tsv1, comps = 3:4, legendpos = "topright", labels = c(401:2500), xlab = "Wavelength (nm)")
abline(h=0)
R2(tsv1)
summary(tsv3.bands.lm)
tsv3.bands.pls = plsr(TSV ~ B1 + B2 + B3 + B4, data = tsv.bands.df) # PLS Model
R2(tsv3.bands.pls)
tsv.bands.df = data.frame(TSV = mmtsv$TSV, B1 = band1, B2 = band2, B3 = band3, B4 = band4) # Combine data together
# Linear Regression
tsv3.bands.lm = lm(TSV ~ B1 + B2 + B3 + B4, data = tsv.bands.df) # OLS Linear Model
summary(tsv3.bands.lm)
# PLS Regression
tsv3.bands.pls = plsr(TSV ~ B1 + B2 + B3 + B4, data = tsv.bands.df) # PLS Model
R2(tsv3.bands.pls)
R2(tsv3.bands.pls)
summary(tsv3.bands.lm)
summary(tsv3.bands.pls)
summary(tsv3.band.pls)
summary(tsv1)
summary(tsv3.bands.lm)
tsv3.bands.pls = plsr(TSV ~ B1 + B2 + B3 + B4, data = tsv.bands.df) # PLS Model
summary(tsv3.bands.pls)
par(mfrow=c(1,1))
loadingplot(tsv1, comps = 1:2, legendpos = "topright", labels = c(401:2500), xlab = "Wavelength (nm)")
abline(h=0)
loadingplot(tsv1, comps = 3:4, legendpos = "topright", labels = c(401:2500), xlab = "Wavelength (nm)")
abline(h=0)
R2(tsv3.bands.pls)
data.frame(Reduced = R2(tsv2.red)$val[1,1,1:11], Full = R2(tsv1)$val[1,1,1:11], FourBands = R2(tsv3.bands.pls)$val[1,1,1:11])
data.frame(Reduced = R2(tsv2.red)$val[1,1,1:11], Full = R2(tsv1)$val[1,1,1:11], FourBands = R2(tsv3.bands.pls)$val[1,1,1:11])
R2(tsv3.bands.pls)
R2(tsv3.bands.pls)$val
R2(tsv3.bands.pls)$val[1,1]
str(R2(tsv3.bands.pls)$val)
data.frame(Reduced = R2(tsv2.red)$val[1,1,1:11], Full = R2(tsv1)$val[1,1,1:11], FourBands = R2(tsv3.bands.pls)$val[1,1,1:5])
data.frame(Reduced = R2(tsv2.red)$val[1,1,1:11], Full = R2(tsv1)$val[1,1,1:11], FourBands = R2(tsv3.bands.pls)$val[1,1,1:5])
data.frame(FourBands = R2(tsv3.bands.pls)$val[1,1,1:5])
? R2
R2(tsv1, ncomp = 1)
R2(tsv1) # newdata here should point to a test-set, if available
data.frame(R2(tsv1)) # newdata here should point to a test-set, if available
data.frame(R2(tsv1)$val[1,1,1:11]) # newdata here should point to a test-set, if available
rmse.plot = plot(RMSEP(tsv1), legendpos = "topright", main = "LOO Validation Error")
plot(RMSEP(tsv2.red), legendpos = "topright", main = "Reduced Model")
RMSEP(tsv3.bands.pls)
class(RMSEP(tsv3.bands.pls))
RMSEP(tsv1)
RMSEP(tsv2.red)
RMSEP(tsv3.bands.pls)
library(pls)
? pls
? R2
View(reflectance)
? which
? merge
#set path to repository
if (file.exists('C:/Users/selmendorf/Documents/ATBDS/ATBDgit/organismalIPT')){
myPathToIPTrepo<-'C:/Users/selmendorf/Documents/ATBDS/ATBDgit/organismalIPT'
}
if (file.exists('C:/Users/cflagg/Documents/GitHub/organismalIPT')){
myPathToIPTrepo<-'C:/Users/cflagg/Documents/GitHub/organismalIPT'
}
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
chirp <- data.frame(mOrder = c(1,2,3,4,7),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
noodles$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird", noodles$protocol)
noodles
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
chirp <- data.frame(mOrder = c(1,2,3,4,7),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
chirp
noodles
noodles$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$protocol)
noodles
noodles$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder && noodles$plotType == 'base', "bird!", noodles$protocol)
noodles
noodles2 = noodles
# %in% is used to compare the two vectors
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$protocol)
noodles2
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$protocol)
noodles2 = noodles
noodles
noodles2
# target table to modify - row 3 has data that should not match your replacement criteria (not a base plot)
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
# inspect table
noodles
# source table to modify - row 5 has data that should not match replacement criteria (mOrder mismatch)
chirp <- data.frame(mOrder = c(1,2,3,4,7),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
# inspect table
chirp
noodles2 = noodles
# %in% is used to compare the two vectors
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$protocol)
# inspect new noodles table
noodles
noodles2
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles2$protocol)
# inspect new noodles table
noodles2
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$plotType)
# inspect new noodles table
noodles2
? ifelse
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles)
# inspect new noodles table
noodles2
# target table to modify - row 3 has data that should not match your replacement criteria (not a base plot)
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
# inspect table
noodles
# source table to modify - row 5 has data that should not match replacement criteria (mOrder mismatch)
chirp <- data.frame(mOrder = c(1,2,3,4,7),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
# inspect table
chirp
noodles2 = noodles
# %in% is used to compare the two vectors, along with &
# in plain english: if morton order of noodles is in the morton order of chirp
# AND noodles plot type is 'base',
# give it "bird!",
# else give it the original
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles2)
# inspect new noodles table
noodles2
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", as.character(noodles2)
# inspect new noodles table
noodles2
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", as.character(noodles2$protocol)
)
noodles2
# give it "bird!",
# else give it the original
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", as.character(noodles2$protocol))
# inspect new noodles table
noodles2
is.factor(noodles$protocol)
is.factor(noodles$plotType)
is.factor(noodles$mOrder)
# target table to modify - row 3 has data that should not match your replacement criteria (not a base plot)
noodles <- cbind(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"))
noodles
noodles$protocol
is.factor(noodles$protocol)
class(noodle)
class(noodles)
# target table to modify - row 3 has data that should not match your replacement criteria (not a base plot)
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"), stringsAsFactors=FALSE)
noodles
class(noodles$protocol)
# target table to modify - row 3 has data that should not match your replacement criteria (not a base plot)
noodles <- data.frame(mOrder = c(1,2,3,4,5),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"), stringsAsFactors=FALSE)
# inspect table
noodles
# source table to modify - row 5 has data that should not match replacement criteria (mOrder mismatch)
chirp <- data.frame(mOrder = c(1,2,3,4,7),
plotType = c("base","base","not","base","base"),
protocol = c("y","y","n","y","y"), stringsAsFactors=FALSE)
chirp
noodles2$protocol <- ifelse(noodles$mOrder %in% chirp$mOrder & noodles$plotType == 'base', "bird!", noodles$protocol)
# inspect new noodles table
noodles2
noodles3 = noodles
noodles3[noodles$plotType == 'base' & noodles$mOrder == chirp$mOrder] <- "bird!"
noodles3[noodles$plotType == 'base' & noodles$mOrder = chirp$mOrder] <- "bird!"
noodles3[noodles$plotType == 'base' && noodles$mOrder == chirp$mOrder] <- "bird!"
noodles3
noodles3$protocol[noodles$plotType == 'base' && noodles$mOrder == chirp$mOrder] <- "bird!"
noodles3
noodles3 = noodles
noodles3$protocol[noodles$plotType == 'base' && noodles$mOrder == chirp$mOrder] <- "bird!"
noodles3
############################################ An Alternative using indexing ############################################
noodles3 = noodles
noodles3$protocol[noodles$plotType == 'base' & noodles$mOrder == chirp$mOrder] <- "bird!"
noodles3
noodles
noodles3
library(plyr)
count(noodles$plotType)
ddply(noodles3, group = plotType, summarise, plotCount = count(plotType))
? ddply
ddply(noodles3, variables = plotType, summarise, plotCount = count(plotType))
ddply(noodles3, .(plotType), summarise, plotCount = count(plotType))
ddply(noodles3, .(plotType), summarise,
plotCount = count(protocol))
ddply(noodles3, .(plotType), summarise,
Count = count(protocol))
noodles3
count
ddply(noodles3, .(plotType), summarise,
Count = count(noodles3$protocol))
ddply(noodles3, .(plotType), summarize,
Count = count(noodles3$protocol))
count
nrow
ddply(noodles3, .(plotType), summarize,
Count = nrow(protocol))
noodles3
noodles3 = noodles
# use index and logical operators
noodles3$protocol[noodles$plotType == 'base' & noodles$mOrder == chirp$mOrder] <- "bird"
noodles3
ddply(noodles3, .(plotType), summarize,
Count = nrow(protocol))
ddply(noodles3, .(plotType), summarize,
Count = count(protocol))
ddply(noodles3, .(plotType), summarize,
Countz = count(protocol))
d_ply(noodles3, .(plotType), summarize,
Countz = count(protocol))
noodles3$birdCount = runif(5)
noodles3
noodles3$birdCount = runif(5)*100
noodles3
int
integer
? integer
noodles3$birdCount = integer(runif(5)*100)
noodles3$birdCount = round(runif(5)*100,0)
noodles3
noodles3$birdCount = round(runif(5)*100,0)
noodles3
ddply(noodles3, .(plotType), summarize, birdTotal = sum(birdCount))
install.packages("plyr")
Sys.which('pdflatex')
setwd('C:/Users/cflagg/Desktop/MyDocuments/GitHub/codingSupportGroup/creatingFunctions/flowControlStructures')
getwd()
setwd('C:/Users/cflagg/Desktop/Documents/GitHub/codingSupportGroup/creatingFunctions/flowControlStructures')
setwd('C:/Users/cflagg/Documents/GitHub/codingSupportGroup/creatingFunctions/flowControlStructures')
plotfile <- read.csv('plotSpatialData_batch2.csv',stringsAsFactors=F)
pointfile <- read.csv('pointSpatialData_batch2.csv',stringsAsFactors=F)
modsPerPlot<-read.csv('applicableModules_30mar2015.csv',stringsAsFactors=F)
reportPlots<-function(appModsData, mod, pointData, pointList){
#Make list of plotIDs where sampling of the mod is occurring (the mod is in the applicableModules list)
plts<-unique(appModsData$plotID[which(grepl(mod,appModsData$applicableModules))])
#Initiate empty vectors to hold results of missing points checks
missingPlts<- vector(); missingPts<-vector()
#For each plotID in the list created above, subset the data by that plotID and see if all of the
#  points in the pointList are in the subset. If not, report the plotID and the missing point(s)
for (p in plts){
sub<-pointData[which(pointData$plotID == p & grepl(mod,pointData$applicableModules)),]
if (nrow(sub)>1){  #only proceed if the plotID is in the point table (not all plots are in this table)
for (i in pointList){
if (i %in% sub$pointID == FALSE){
missingPts<-c(missingPts,i); missingPlts<-c(missingPlts,p)
}
}
}
}
return (cbind(missingPlts,missingPts))  #Return a dataframe as the output
}
reportPlots
#Run the function for bet and div
#Identify lists of expected points per module
betLst<-c('N','E','W','S')
divLst<-c('31.1.1','31.1.10','31.4.1','31.4.10','32.2.1','32.2.10','32.4.1','32.4.10','40.1.1','40.1.10',
'40.3.1','40.3.10','41.1.1','41.1.10','41.4.1','41.4.10',31,41,40,32)
#Call function, once for each module
missingBetPts<-reportPlots(modsPerPlot, 'bet', pointfile, betLst)
missingBetPts  #No missing points found
missingDivPts<-reportPlots(modsPerPlot, 'div', pointfile, divLst)
missingDivPts  #Several missing points found
missingBetPts<-reportPlots(modsPerPlot, 'bet', pointfile, betLst)
missingBetPts  #No missing points found
missingDivPts<-reportPlots(modsPerPlot, 'div', pointfile, divLst)
missingDivPts  #Several missing points found
? match
which
? which
seq(1,10,1)
x1 = seq(1,10,1)
y1 = seq(5,10,1)
y1 %in% x1
x1 %in% y1
x1[which(y1)]
x1[which(y1),]
which(x1,y1)
which(x1,arr.ind == y1)
x1[which(x1==y1)]
x1[which(y1==x1)]
list = NULL
median(num)
num = 1:10
i = 1
median(num)
med = median(num)
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
i = i + 1
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print(i)
i = i + 1
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print(i)
i = i + 1
print(i)
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print("num",num)
i = i + 1
print("i",i)
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print("num",num[i])
i = i + 1
print("i",i)
}
? print
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print(paste("num",num[i])
i = i + 1
print(paste("i",i))
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print(paste0("num",num[i])
i = i + 1
print(paste0("i",i))
}
num = 1:10
i = 1
med = median(num)
while (i < med){
num[i] = num[i] + 5
print(paste0("num",num[i]))
i = i + 1
print(paste0("i",i))
}
repeat
repeat()
repeat
? repeat
##  For a given author, randomly assign two reviewers from a pool of reviewers that may include the author
# Define the list of authors
authors = c("Springer","Hoekman","Hinckley","Elmendorf")
# Define the list of reviewers
reviewers = c("Springer","Hinckley","Stanish","Meier","LeVan","Thibault","Elmendorf","Jones")
# Use a 'for' loop to randomly assign two reviewers from the 'reviewers' list to each element of 'authors'
for (i in 1:length(authors)){
x = NA
repeat {
x = sample(reviewers, 2, replace=FALSE);
if (!authors[i] %in% x)
break;
}
# Display output on the screen: author first, then two selected reviewers
print(paste(authors[i], x, sep=","))
# Update the list of reviewers so that reviewers do not get assigned to multiple authors
reviewers = reviewers[!reviewers %in% x]
}
# Use a 'for' loop to randomly assign two reviewers from the 'reviewers' list to each element of 'authors'
for (i in 1:length(authors)){
x = NA
repeat {
x = sample(reviewers, 2, replace=FALSE);
if (!authors[i] %in% x)
break;
}
# Display output on the screen: author first, then two selected reviewers
print(paste(authors[i], x, sep=","))
# Update the list of reviewers so that reviewers do not get assigned to multiple authors
reviewers = reviewers[!reviewers %in% x]
}
# Use a 'for' loop to randomly assign two reviewers from the 'reviewers' list to each element of 'authors'
for (i in 1:length(authors)){
x = NA
repeat {
x = sample(reviewers, 2, replace=FALSE);
if (!authors[i] %in% x)
break;
}
# Display output on the screen: author first, then two selected reviewers
print(paste(authors[i], x, sep=","))
# Update the list of reviewers so that reviewers do not get assigned to multiple authors
reviewers = reviewers[!reviewers %in% x]
}
authors = c("Springer","Hoekman","Hinckley","Elmendorf")
# Define the list of reviewers
reviewers = c("Springer","Hinckley","Stanish","Meier","LeVan","Thibault","Elmendorf","Jones")
for (i in 1:length(authors)){
x = NA
repeat {
x = sample(reviewers, 2, replace=FALSE);
if (!authors[i] %in% x)
break;
}
# Display output on the screen: author first, then two selected reviewers
print(paste(authors[i], x, sep=","))
# Update the list of reviewers so that reviewers do not get assigned to multiple authors
reviewers = reviewers[!reviewers %in% x]
}
# Define the list of authors
authors = c("Springer","Hoekman","Hinckley","Elmendorf")
# Define the list of reviewers
reviewers = c("Springer","Hinckley","Stanish","Meier","LeVan","Thibault","Elmendorf","Jones")
# Use
# Define the list of authors
authors = c("Springer","Hoekman","Hinckley","Elmendorf")
# Define the list of reviewers
reviewers = c("Springer","Hinckley","Stanish","Meier","LeVan","Thibault","Elmendorf","Jones")
# Use a 'for' loop to randomly assign two reviewers from the 'reviewers' list to each element of 'authors'
for (i in 1:length(authors)){
x = NA
repeat {
x = sample(reviewers, 2, replace=FALSE);
if (-authors[i] %in% x)
break;
}
# Display output on the screen: author first, then two selected reviewers
print(paste(authors[i], x, sep=","))
# Update the list of reviewers so that reviewers do not get assigned to multiple authors
reviewers = reviewers[!reviewers %in% x]
}
